{"version":3,"sources":["webpack:///src/webgl/MV.js","webpack:///src/webgl/webgl-utils.js","webpack:///src/webgl/fileUtils.js","webpack:///src/webgl/initShaders.js","webpack:///src/webgl/webgl-colors.js","webpack:///src/webgl/webgl-constants.js","webpack:///src/webgl/webgl-ctrl.js","webpack:///src/webgl/webgl-render.js","webpack:///src/webgl/webgl-setup.js","webpack:///src/webgl/webgl-shapes.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B;AAC1B;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B;AAC1B,0BAA0B;AAC1B;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B;AAC1B,0BAA0B;AAC1B,0BAA0B;AAC1B;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,cAAc;;AAE/C;AACA,wBAAwB,cAAc;AACtC,+CAA+C,cAAc;AAC7D,4BAA4B,iBAAiB;AAC7C,4CAA4C,cAAc;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC,kCAAkC,cAAc;AAChD;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,cAAc;AACtC;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,cAAc;AACtC;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;;AAEA,wBAAwB,cAAc;AACtC;;AAEA,4BAA4B,cAAc;AAC1C;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,sBAAsB,YAAY;AAClC;AACA,sBAAsB,YAAY;AAClC;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;AAEA,wBAAwB,cAAc;AACtC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2CAA2C;AAC3C,sCAAsC;AACtC,qCAAqC;;AAErC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,2CAA2C;AACrE,0BAA0B,2CAA2C;AACrE,0BAA0B,yCAAyC;;AAEnE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,cAAc;AAClC;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,cAAc;AAClC;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,oBAAoB,cAAc;AAClC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,cAAc;AAClC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,cAAc;AAClC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,wBAAwB,cAAc;AACtC,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,IAAI,iBAAiB,KAAK;AAC1C;AACA;;AAEA;;CCl9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,oBAAoB;AACpB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,0CAA0C,aAAa,cAAc;AACrE;AACA,qCAAqC,wBAAwB;AAC7D;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,+BAA+B;AAC1C;AACA,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;CCjKD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;CCVA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;CCtCA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;CCnFA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;CC7BA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,UAAU;AAC9B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,OAAO;AAC5B;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;CCrMA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;CC1LA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wGAAwG;AACxG,2GAA2G;AAC3G,8GAA8G;AAC9G;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;CC3TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,aAAa;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,aAAa;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH","file":"scripts.js","sourcesContent":["//////////////////////////////////////////////////////////////////////////////\n//\n//  Angel.js\n//\n//////////////////////////////////////////////////////////////////////////////\n\n//----------------------------------------------------------------------------\n//\n//  Helper functions\n//\n\nfunction _argumentsToArray( args )\n{\n    return [].concat.apply( [], Array.prototype.slice.apply(args) );\n}\n\n//----------------------------------------------------------------------------\n\nfunction radians( degrees ) {\n    return degrees * Math.PI / 180.0;\n}\n\n//----------------------------------------------------------------------------\n//\n//  Vector Constructors\n//\n\nfunction vec2()\n{\n    var result = _argumentsToArray( arguments );\n\n    switch ( result.length ) {\n    case 0: result.push( 0.0 );\n    case 1: result.push( 0.0 );\n    }\n\n    return result.splice( 0, 2 );\n}\n\nfunction vec3()\n{\n    var result = _argumentsToArray( arguments );\n\n    switch ( result.length ) {\n    case 0: result.push( 0.0 );\n    case 1: result.push( 0.0 );\n    case 2: result.push( 0.0 );\n    }\n\n    return result.splice( 0, 3 );\n}\n\nfunction vec4()\n{\n    var result = _argumentsToArray( arguments );\n\n    switch ( result.length ) {\n    case 0: result.push( 0.0 );\n    case 1: result.push( 0.0 );\n    case 2: result.push( 0.0 );\n    case 3: result.push( 1.0 );\n    }\n\n    return result.splice( 0, 4 );\n}\n\n//----------------------------------------------------------------------------\n//\n//  Matrix Constructors\n//\n\nfunction mat2()\n{\n    var v = _argumentsToArray( arguments );\n\n    var m = [];\n    switch ( v.length ) {\n    case 0:\n        v[0] = 1;\n    case 1:\n        m = [\n            vec2( v[0],  0.0 ),\n            vec2(  0.0, v[0] )\n        ];\n        break;\n\n    default:\n        m.push( vec2(v) );  v.splice( 0, 2 );\n        m.push( vec2(v) );\n        break;\n    }\n\n    m.matrix = true;\n\n    return m;\n}\n\n//----------------------------------------------------------------------------\n\nfunction mat3()\n{\n    var v = _argumentsToArray( arguments );\n\n    var m = [];\n    switch ( v.length ) {\n    case 0:\n        v[0] = 1;\n    case 1:\n        m = [\n            vec3( v[0],  0.0,  0.0 ),\n            vec3(  0.0, v[0],  0.0 ),\n            vec3(  0.0,  0.0, v[0] )\n        ];\n        break;\n\n    default:\n        m.push( vec3(v) );  v.splice( 0, 3 );\n        m.push( vec3(v) );  v.splice( 0, 3 );\n        m.push( vec3(v) );\n        break;\n    }\n\n    m.matrix = true;\n\n    return m;\n}\n\n//----------------------------------------------------------------------------\n\nfunction mat4()\n{\n    var v = _argumentsToArray( arguments );\n\n    var m = [];\n    switch ( v.length ) {\n    case 0:\n        v[0] = 1;\n    case 1:\n        m = [\n            vec4( v[0], 0.0,  0.0,   0.0 ),\n            vec4( 0.0,  v[0], 0.0,   0.0 ),\n            vec4( 0.0,  0.0,  v[0],  0.0 ),\n            vec4( 0.0,  0.0,  0.0,  v[0] )\n        ];\n        break;\n\n    default:\n        m.push( vec4(v) );  v.splice( 0, 4 );\n        m.push( vec4(v) );  v.splice( 0, 4 );\n        m.push( vec4(v) );  v.splice( 0, 4 );\n        m.push( vec4(v) );\n        break;\n    }\n\n    m.matrix = true;\n\n    return m;\n}\n\n//----------------------------------------------------------------------------\n//\n//  Generic Mathematical Operations for Vectors and Matrices\n//\n\nfunction equal( u, v )\n{\n    if ( u.length != v.length ) { return false; }\n\n    if ( u.matrix && v.matrix ) {\n        for ( var i = 0; i < u.length; ++i ) {\n            if ( u[i].length != v[i].length ) { return false; }\n            for ( var j = 0; j < u[i].length; ++j ) {\n                if ( u[i][j] !== v[i][j] ) { return false; }\n            }\n        }\n    }\n    else if ( u.matrix && !v.matrix || !u.matrix && v.matrix ) {\n        return false;\n    }\n    else {\n        for ( var i = 0; i < u.length; ++i ) {\n            if ( u[i] !== v[i] ) { return false; }\n        }\n    }\n\n    return true;\n}\n\n//----------------------------------------------------------------------------\n\nfunction add( u, v )\n{\n    var result = [];\n\n    if ( u.matrix && v.matrix ) {\n        if ( u.length != v.length ) {\n            throw \"add(): trying to add matrices of different dimensions\";\n        }\n\n        for ( var i = 0; i < u.length; ++i ) {\n            if ( u[i].length != v[i].length ) {\n                throw \"add(): trying to add matrices of different dimensions\";\n            }\n            result.push( [] );\n            for ( var j = 0; j < u[i].length; ++j ) {\n                result[i].push( u[i][j] + v[i][j] );\n            }\n        }\n\n        result.matrix = true;\n\n        return result;\n    }\n    else if ( u.matrix && !v.matrix || !u.matrix && v.matrix ) {\n        throw \"add(): trying to add matrix and non-matrix variables\";\n    }\n    else {\n        if ( u.length != v.length ) {\n            throw \"add(): vectors are not the same dimension\";\n        }\n\n        for ( var i = 0; i < u.length; ++i ) {\n            result.push( u[i] + v[i] );\n        }\n\n        return result;\n    }\n}\n\n//----------------------------------------------------------------------------\n\nfunction subtract( u, v )\n{\n    var result = [];\n\n    if ( u.matrix && v.matrix ) {\n        if ( u.length != v.length ) {\n            throw \"subtract(): trying to subtract matrices\" +\n                \" of different dimensions\";\n        }\n\n        for ( var i = 0; i < u.length; ++i ) {\n            if ( u[i].length != v[i].length ) {\n                throw \"subtract(): trying to subtact matrices\" +\n                    \" of different dimensions\";\n            }\n            result.push( [] );\n            for ( var j = 0; j < u[i].length; ++j ) {\n                result[i].push( u[i][j] - v[i][j] );\n            }\n        }\n\n        result.matrix = true;\n\n        return result;\n    }\n    else if ( u.matrix && !v.matrix || !u.matrix && v.matrix ) {\n        throw \"subtact(): trying to subtact  matrix and non-matrix variables\";\n    }\n    else {\n        if ( u.length != v.length ) {\n            throw \"subtract(): vectors are not the same length\";\n        }\n\n        for ( var i = 0; i < u.length; ++i ) {\n            result.push( u[i] - v[i] );\n        }\n\n        return result;\n    }\n}\n\n//----------------------------------------------------------------------------\n\nfunction mult( u, v )\n{\n    var result = [];\n\n    if ( u.matrix && v.matrix ) {\n        if ( u.length != v.length ) {\n            throw \"mult(): trying to add matrices of different dimensions\";\n        }\n\n        for ( var i = 0; i < u.length; ++i ) {\n            if ( u[i].length != v[i].length ) {\n                throw \"mult(): trying to add matrices of different dimensions\";\n            }\n        }\n\n        for ( var i = 0; i < u.length; ++i ) {\n            result.push( [] );\n\n            for ( var j = 0; j < v.length; ++j ) {\n                var sum = 0.0;\n                for ( var k = 0; k < u.length; ++k ) {\n                    sum += u[i][k] * v[k][j];\n                }\n                result[i].push( sum );\n            }\n        }\n\n        result.matrix = true;\n\n        return result;\n    }\n\n      if(u.matrix&& (u.length == v.length)) {\n        for(var i = 0; i<v.length; i++) {\n          var sum = 0.0;\n          for(var j=0; j<v.length; j++) {\n            sum += u[i][j]*v[j];\n          }\n          result.push(sum);\n        }\n      return result;\n      }\n\n\n\n    else {\n        if ( u.length != v.length ) {\n            throw \"mult(): vectors are not the same dimension\";\n        }\n\n        for ( var i = 0; i < u.length; ++i ) {\n            result.push( u[i] * v[i] );\n        }\n\n        return result;\n    }\n}\n\n//----------------------------------------------------------------------------\n//\n//  Basic Transformation Matrix Generators\n//\n\nfunction translate( x, y, z )\n{\n    if ( Array.isArray(x) && x.length == 3 ) {\n        z = x[2];\n        y = x[1];\n        x = x[0];\n    }\n\n    var result = mat4();\n    result[0][3] = x;\n    result[1][3] = y;\n    result[2][3] = z;\n\n    return result;\n}\n\n//----------------------------------------------------------------------------\n\nfunction rotate( angle, axis )\n{\n    if ( !Array.isArray(axis) ) {\n        axis = [ arguments[1], arguments[2], arguments[3] ];\n    }\n\n    var v = normalize( axis );\n\n    var x = v[0];\n    var y = v[1];\n    var z = v[2];\n\n    var c = Math.cos( radians(angle) );\n    var omc = 1.0 - c;\n    var s = Math.sin( radians(angle) );\n\n    var result = mat4(\n        vec4( x*x*omc + c,   x*y*omc - z*s, x*z*omc + y*s, 0.0 ),\n        vec4( x*y*omc + z*s, y*y*omc + c,   y*z*omc - x*s, 0.0 ),\n        vec4( x*z*omc - y*s, y*z*omc + x*s, z*z*omc + c,   0.0 ),\n        vec4()\n    );\n\n    return result;\n}\n\nfunction rotateX(theta) {\n  var c = Math.cos( radians(theta) );\n  var s = Math.sin( radians(theta) );\n  var rx = mat4( 1.0,  0.0,  0.0, 0.0,\n      0.0,  c,  -s, 0.0,\n      0.0, s,  c, 0.0,\n      0.0,  0.0,  0.0, 1.0 );\n  return rx;\n}\nfunction rotateY(theta) {\n  var c = Math.cos( radians(theta) );\n  var s = Math.sin( radians(theta) );\n  var ry = mat4( c, 0.0, s, 0.0,\n      0.0, 1.0,  0.0, 0.0,\n      -s, 0.0,  c, 0.0,\n      0.0, 0.0,  0.0, 1.0 );\n  return ry;\n}\nfunction rotateZ(theta) {\n  var c = Math.cos( radians(theta) );\n  var s = Math.sin( radians(theta) );\n  var rz = mat4( c, -s, 0.0, 0.0,\n      s,  c, 0.0, 0.0,\n      0.0,  0.0, 1.0, 0.0,\n      0.0,  0.0, 0.0, 1.0 );\n  return rz;\n}\n\n\n//----------------------------------------------------------------------------\n\nfunction scalem( x, y, z )\n{\n    if ( Array.isArray(x) && x.length == 3 ) {\n        z = x[2];\n        y = x[1];\n        x = x[0];\n    }\n\n    var result = mat4();\n    result[0][0] = x;\n    result[1][1] = y;\n    result[2][2] = z;\n\n    return result;\n}\n\n//----------------------------------------------------------------------------\n//\n//  ModelView Matrix Generators\n//\n\nfunction lookAt( eye, at, up )\n{\n    if ( !Array.isArray(eye) || eye.length != 3) {\n        throw \"lookAt(): first parameter [eye] must be an a vec3\";\n    }\n\n    if ( !Array.isArray(at) || at.length != 3) {\n        throw \"lookAt(): first parameter [at] must be an a vec3\";\n    }\n\n    if ( !Array.isArray(up) || up.length != 3) {\n        throw \"lookAt(): first parameter [up] must be an a vec3\";\n    }\n\n    if ( equal(eye, at) ) {\n        return mat4();\n    }\n\n    var v = normalize( subtract(at, eye) );  // view direction vector\n    var n = normalize( cross(v, up) );       // perpendicular vector\n    var u = normalize( cross(n, v) );        // \"new\" up vector\n\n    v = negate( v );\n\n    var result = mat4(\n        vec4( n, -dot(n, eye) ),\n        vec4( u, -dot(u, eye) ),\n        vec4( v, -dot(v, eye) ),\n        vec4()\n    );\n\n    return result;\n}\n\n//----------------------------------------------------------------------------\n//\n//  Projection Matrix Generators\n//\n\nfunction ortho( left, right, bottom, top, near, far )\n{\n    if ( left == right ) { throw \"ortho(): left and right are equal\"; }\n    if ( bottom == top ) { throw \"ortho(): bottom and top are equal\"; }\n    if ( near == far )   { throw \"ortho(): near and far are equal\"; }\n\n    var w = right - left;\n    var h = top - bottom;\n    var d = far - near;\n\n    var result = mat4();\n    result[0][0] = 2.0 / w;\n    result[1][1] = 2.0 / h;\n    result[2][2] = -2.0 / d;\n    result[0][3] = -(left + right) / w;\n    result[1][3] = -(top + bottom) / h;\n    result[2][3] = -(near + far) / d;\n\n    return result;\n}\n\n//----------------------------------------------------------------------------\n\nfunction perspective( fovy, aspect, near, far )\n{\n    var f = 1.0 / Math.tan( radians(fovy) / 2 );\n    var d = far - near;\n\n    var result = mat4();\n    result[0][0] = f / aspect;\n    result[1][1] = f;\n    result[2][2] = -(near + far) / d;\n    result[2][3] = -2 * near * far / d;\n    result[3][2] = -1;\n    result[3][3] = 0.0;\n\n    return result;\n}\n\n//----------------------------------------------------------------------------\n//\n//  Matrix Functions\n//\n\nfunction transpose( m )\n{\n    if ( !m.matrix ) {\n        return \"transpose(): trying to transpose a non-matrix\";\n    }\n\n    var result = [];\n    for ( var i = 0; i < m.length; ++i ) {\n        result.push( [] );\n        for ( var j = 0; j < m[i].length; ++j ) {\n            result[i].push( m[j][i] );\n        }\n    }\n\n    result.matrix = true;\n\n    return result;\n}\n\n//----------------------------------------------------------------------------\n//\n//  Vector Functions\n//\n\nfunction dot( u, v )\n{\n    if ( u.length != v.length ) {\n        throw \"dot(): vectors are not the same dimension\";\n    }\n\n    var sum = 0.0;\n    for ( var i = 0; i < u.length; ++i ) {\n        sum += u[i] * v[i];\n    }\n\n    return sum;\n}\n\n//----------------------------------------------------------------------------\n\nfunction negate( u )\n{\n    var result = [];\n    for ( var i = 0; i < u.length; ++i ) {\n        result.push( -u[i] );\n    }\n\n    return result;\n}\n\n//----------------------------------------------------------------------------\n\nfunction cross( u, v )\n{\n    if ( !Array.isArray(u) || u.length < 3 ) {\n        throw \"cross(): first argument is not a vector of at least 3\";\n    }\n\n    if ( !Array.isArray(v) || v.length < 3 ) {\n        throw \"cross(): second argument is not a vector of at least 3\";\n    }\n\n    var result = [\n        u[1]*v[2] - u[2]*v[1],\n        u[2]*v[0] - u[0]*v[2],\n        u[0]*v[1] - u[1]*v[0]\n    ];\n\n    return result;\n}\n\n//----------------------------------------------------------------------------\n\nfunction length( u )\n{\n    return Math.sqrt( dot(u, u) );\n}\n\n//----------------------------------------------------------------------------\n\nfunction normalize( u, excludeLastComponent )\n{\n    if ( excludeLastComponent ) {\n        var last = u.pop();\n    }\n\n    var len = length( u );\n\n    if ( !isFinite(len) ) {\n        throw \"normalize: vector \" + u + \" has zero length\";\n    }\n\n    for ( var i = 0; i < u.length; ++i ) {\n        u[i] /= len;\n    }\n\n    if ( excludeLastComponent ) {\n        u.push( last );\n    }\n\n    return u;\n}\n\n//----------------------------------------------------------------------------\n\nfunction mix( u, v, s )\n{\n    if ( typeof s !== \"number\" ) {\n        throw \"mix: the last paramter \" + s + \" must be a number\";\n    }\n\n    if ( u.length != v.length ) {\n        throw \"vector dimension mismatch\";\n    }\n\n    var result = [];\n    for ( var i = 0; i < u.length; ++i ) {\n        result.push( (1.0 - s) * u[i] + s * v[i] );\n    }\n\n    return result;\n}\n\n//----------------------------------------------------------------------------\n//\n// Vector and Matrix functions\n//\n\nfunction scale( s, u )\n{\n    if ( !Array.isArray(u) ) {\n        throw \"scale: second parameter \" + u + \" is not a vector\";\n    }\n\n    var result = [];\n    for ( var i = 0; i < u.length; ++i ) {\n        result.push( s * u[i] );\n    }\n\n    return result;\n}\n\n//----------------------------------------------------------------------------\n//\n//\n//\n\nfunction flatten( v )\n{\n    if ( v.matrix === true ) {\n        v = transpose( v );\n    }\n\n    var n = v.length;\n    var elemsAreArrays = false;\n\n    if ( Array.isArray(v[0]) ) {\n        elemsAreArrays = true;\n        n *= v[0].length;\n    }\n\n    var floats = new Float32Array( n );\n\n    if ( elemsAreArrays ) {\n        var idx = 0;\n        for ( var i = 0; i < v.length; ++i ) {\n            for ( var j = 0; j < v[i].length; ++j ) {\n                floats[idx++] = v[i][j];\n            }\n        }\n    }\n    else {\n        for ( var i = 0; i < v.length; ++i ) {\n            floats[i] = v[i];\n        }\n    }\n\n    return floats;\n}\n\n//----------------------------------------------------------------------------\n\nvar sizeof = {\n    'vec2' : new Float32Array( flatten(vec2()) ).byteLength,\n    'vec3' : new Float32Array( flatten(vec3()) ).byteLength,\n    'vec4' : new Float32Array( flatten(vec4()) ).byteLength,\n    'mat2' : new Float32Array( flatten(mat2()) ).byteLength,\n    'mat3' : new Float32Array( flatten(mat3()) ).byteLength,\n    'mat4' : new Float32Array( flatten(mat4()) ).byteLength\n};\n\n// new functions 5/2/2015\n\n// printing\n\nfunction printm(m)\n{\n    if(m.length == 2)\n    for(var i=0; i<m.length; i++)\n       console.log(m[i][0], m[i][1]);\n    else if(m.length == 3)\n    for(var i=0; i<m.length; i++)\n       console.log(m[i][0], m[i][1], m[i][2]);\n    else if(m.length == 4)\n    for(var i=0; i<m.length; i++)\n       console.log(m[i][0], m[i][1], m[i][2], m[i][3]);\n}\n// determinants\n\nfunction det2(m)\n{\n\n     return m[0][0]*m[1][1]-m[0][1]*m[1][0];\n\n}\n\nfunction det3(m)\n{\n     var d = m[0][0]*m[1][1]*m[2][2]\n           + m[0][1]*m[1][2]*m[2][0]\n           + m[0][2]*m[2][1]*m[1][0]\n           - m[2][0]*m[1][1]*m[0][2]\n           - m[1][0]*m[0][1]*m[2][2]\n           - m[0][0]*m[1][2]*m[2][1]\n           ;\n     return d;\n}\n\nfunction det4(m)\n{\n     var m0 = [\n         vec3(m[1][1], m[1][2], m[1][3]),\n         vec3(m[2][1], m[2][2], m[2][3]),\n         vec3(m[3][1], m[3][2], m[3][3])\n     ];\n     var m1 = [\n         vec3(m[1][0], m[1][2], m[1][3]),\n         vec3(m[2][0], m[2][2], m[2][3]),\n         vec3(m[3][0], m[3][2], m[3][3])\n     ];\n     var m2 = [\n         vec3(m[1][0], m[1][1], m[1][3]),\n         vec3(m[2][0], m[2][1], m[2][3]),\n         vec3(m[3][0], m[3][1], m[3][3])\n     ];\n     var m3 = [\n         vec3(m[1][0], m[1][1], m[1][2]),\n         vec3(m[2][0], m[2][1], m[2][2]),\n         vec3(m[3][0], m[3][1], m[3][2])\n     ];\n     return m[0][0]*det3(m0) - m[0][1]*det3(m1)\n         + m[0][2]*det3(m2) - m[0][3]*det3(m3);\n\n}\n\nfunction det(m)\n{\n     if(m.matrix != true) console.log(\"not a matrix\");\n     if(m.length == 2) return det2(m);\n     if(m.length == 3) return det3(m);\n     if(m.length == 4) return det4(m);\n}\n\n//---------------------------------------------------------\n\n// inverses\n\nfunction inverse2(m)\n{\n     var a = mat2();\n     var d = det2(m);\n     a[0][0] = m[1][1]/d;\n     a[0][1] = -m[0][1]/d;\n     a[1][0] = -m[1][0]/d;\n     a[1][1] = m[0][0]/d;\n     a.matrix = true;\n     return a;\n}\n\nfunction inverse3(m)\n{\n    var a = mat3();\n    var d = det3(m);\n\n    var a00 = [\n       vec2(m[1][1], m[1][2]),\n       vec2(m[2][1], m[2][2])\n    ];\n    var a01 = [\n       vec2(m[1][0], m[1][2]),\n       vec2(m[2][0], m[2][2])\n    ];\n    var a02 = [\n       vec2(m[1][0], m[1][1]),\n       vec2(m[2][0], m[2][1])\n    ];\n    var a10 = [\n       vec2(m[0][1], m[0][2]),\n       vec2(m[2][1], m[2][2])\n    ];\n    var a11 = [\n       vec2(m[0][0], m[0][2]),\n       vec2(m[2][0], m[2][2])\n    ];\n    var a12 = [\n       vec2(m[0][0], m[0][1]),\n       vec2(m[2][0], m[2][1])\n    ];\n    var a20 = [\n       vec2(m[0][1], m[0][2]),\n       vec2(m[1][1], m[1][2])\n    ];\n    var a21 = [\n       vec2(m[0][0], m[0][2]),\n       vec2(m[1][0], m[1][2])\n    ];\n    var a22 = [\n       vec2(m[0][0], m[0][1]),\n       vec2(m[1][0], m[1][1])\n    ];\n\n   a[0][0] = det2(a00)/d;\n   a[0][1] = -det2(a10)/d;\n   a[0][2] = det2(a20)/d;\n   a[1][0] = -det2(a01)/d;\n   a[1][1] = det2(a11)/d;\n   a[1][2] = -det2(a21)/d;\n   a[2][0] = det2(a02)/d;\n   a[2][1] = -det2(a12)/d;\n   a[2][2] = det2(a22)/d;\n\n   return a;\n\n}\n\nfunction inverse4(m)\n{\n    var a = mat4();\n    var d = det4(m);\n\n    var a00 = [\n       vec3(m[1][1], m[1][2], m[1][3]),\n       vec3(m[2][1], m[2][2], m[2][3]),\n       vec3(m[3][1], m[3][2], m[3][3])\n    ];\n    var a01 = [\n       vec3(m[1][0], m[1][2], m[1][3]),\n       vec3(m[2][0], m[2][2], m[2][3]),\n       vec3(m[3][0], m[3][2], m[3][3])\n    ];\n    var a02 = [\n       vec3(m[1][0], m[1][1], m[1][3]),\n       vec3(m[2][0], m[2][1], m[2][3]),\n       vec3(m[3][0], m[3][1], m[3][3])\n    ];\n    var a03 = [\n       vec3(m[1][0], m[1][1], m[1][2]),\n       vec3(m[2][0], m[2][1], m[2][2]),\n       vec3(m[3][0], m[3][1], m[3][2])\n    ];\n    var a10 = [\n       vec3(m[0][1], m[0][2], m[0][3]),\n       vec3(m[2][1], m[2][2], m[2][3]),\n       vec3(m[3][1], m[3][2], m[3][3])\n    ];\n    var a11 = [\n       vec3(m[0][0], m[0][2], m[0][3]),\n       vec3(m[2][0], m[2][2], m[2][3]),\n       vec3(m[3][0], m[3][2], m[3][3])\n    ];\n    var a12 = [\n       vec3(m[0][0], m[0][1], m[0][3]),\n       vec3(m[2][0], m[2][1], m[2][3]),\n       vec3(m[3][0], m[3][1], m[3][3])\n    ];\n    var a13 = [\n       vec3(m[0][0], m[0][1], m[0][2]),\n       vec3(m[2][0], m[2][1], m[2][2]),\n       vec3(m[3][0], m[3][1], m[3][2])\n    ];\n    var a20 = [\n       vec3(m[0][1], m[0][2], m[0][3]),\n       vec3(m[1][1], m[1][2], m[1][3]),\n       vec3(m[3][1], m[3][2], m[3][3])\n    ];\n    var a21 = [\n       vec3(m[0][0], m[0][2], m[0][3]),\n       vec3(m[1][0], m[1][2], m[1][3]),\n       vec3(m[3][0], m[3][2], m[3][3])\n    ];\n    var a22 = [\n       vec3(m[0][0], m[0][1], m[0][3]),\n       vec3(m[1][0], m[1][1], m[1][3]),\n       vec3(m[3][0], m[3][1], m[3][3])\n    ];\n    var a23 = [\n       vec3(m[0][0], m[0][1], m[0][2]),\n       vec3(m[1][0], m[1][1], m[1][2]),\n       vec3(m[3][0], m[3][1], m[3][2])\n    ];\n\n    var a30 = [\n       vec3(m[0][1], m[0][2], m[0][3]),\n       vec3(m[1][1], m[1][2], m[1][3]),\n       vec3(m[2][1], m[2][2], m[2][3])\n    ];\n    var a31 = [\n       vec3(m[0][0], m[0][2], m[0][3]),\n       vec3(m[1][0], m[1][2], m[1][3]),\n       vec3(m[2][0], m[2][2], m[2][3])\n    ];\n    var a32 = [\n       vec3(m[0][0], m[0][1], m[0][3]),\n       vec3(m[1][0], m[1][1], m[1][3]),\n       vec3(m[2][0], m[2][1], m[2][3])\n    ];\n    var a33 = [\n       vec3(m[0][0], m[0][1], m[0][2]),\n       vec3(m[1][0], m[1][1], m[1][2]),\n       vec3(m[2][0], m[2][1], m[2][2])\n    ];\n\n\n\n   a[0][0] = det3(a00)/d;\n   a[0][1] = -det3(a10)/d;\n   a[0][2] = det3(a20)/d;\n   a[0][3] = -det3(a30)/d;\n   a[1][0] = -det3(a01)/d;\n   a[1][1] = det3(a11)/d;\n   a[1][2] = -det3(a21)/d;\n   a[1][3] = det3(a31)/d;\n   a[2][0] = det3(a02)/d;\n   a[2][1] = -det3(a12)/d;\n   a[2][2] = det3(a22)/d;\n   a[2][3] = -det3(a32)/d;\n   a[3][0] = -det3(a03)/d;\n   a[3][1] = det3(a13)/d;\n   a[3][2] = -det3(a23)/d;\n   a[3][3] = det3(a33)/d;\n\n   return a;\n}\nfunction inverse(m)\n{\n   if(m.matrix != true) console.log(\"not a matrix\");\n   if(m.length == 2) return inverse2(m);\n   if(m.length == 3) return inverse3(m);\n   if(m.length == 4) return inverse4(m);\n}\n\nfunction normalMatrix(m, flag)\n{\n    var a = mat4();\n    a = inverse(transpose(m));\n    if(flag != true) return a;\n    else {\n    var b = mat3();\n    for(var i=0;i<3;i++) for(var j=0; j<3; j++) b[i][j] = a[i][j];\n    return b;\n    }\n\n}\n","/*\r\n * Copyright 2010, Google Inc.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are\r\n * met:\r\n *\r\n *     * Redistributions of source code must retain the above copyright\r\n * notice, this list of conditions and the following disclaimer.\r\n *     * Redistributions in binary form must reproduce the above\r\n * copyright notice, this list of conditions and the following disclaimer\r\n * in the documentation and/or other materials provided with the\r\n * distribution.\r\n *     * Neither the name of Google Inc. nor the names of its\r\n * contributors may be used to endorse or promote products derived from\r\n * this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n\r\n/**\r\n * @fileoverview This file contains functions every webgl program will need\r\n * a version of one way or another.\r\n *\r\n * Instead of setting up a context manually it is recommended to\r\n * use. This will check for success or failure. On failure it\r\n * will attempt to present an approriate message to the user.\r\n *\r\n *       gl = WebGLUtils.setupWebGL(canvas);\r\n *\r\n * For animated WebGL apps use of setTimeout or setInterval are\r\n * discouraged. It is recommended you structure your rendering\r\n * loop like this.\r\n *\r\n *       function render() {\r\n *         window.requestAnimFrame(render, canvas);\r\n *\r\n *         // do rendering\r\n *         ...\r\n *       }\r\n *       render();\r\n *\r\n * This will call your rendering function up to the refresh rate\r\n * of your display but will stop rendering if your app is not\r\n * visible.\r\n */\r\n\r\nWebGLUtils = function() {\r\n\r\n/**\r\n * Creates the HTLM for a failure message\r\n * @param {string} canvasContainerId id of container of th\r\n *        canvas.\r\n * @return {string} The html.\r\n */\r\nvar makeFailHTML = function(msg) {\r\n  return '' +\r\n    '<table style=\"background-color: #8CE; width: 100%; height: 100%;\"><tr>' +\r\n    '<td align=\"center\">' +\r\n    '<div style=\"display: table-cell; vertical-align: middle;\">' +\r\n    '<div style=\"\">' + msg + '</div>' +\r\n    '</div>' +\r\n    '</td></tr></table>';\r\n};\r\n\r\n/**\r\n * Mesasge for getting a webgl browser\r\n * @type {string}\r\n */\r\nvar GET_A_WEBGL_BROWSER = '' +\r\n  'This page requires a browser that supports WebGL.<br/>' +\r\n  '<a href=\"http://get.webgl.org\">Click here to upgrade your browser.</a>';\r\n\r\n/**\r\n * Mesasge for need better hardware\r\n * @type {string}\r\n */\r\nvar OTHER_PROBLEM = '' +\r\n  \"It doesn't appear your computer can support WebGL.<br/>\" +\r\n  '<a href=\"http://get.webgl.org/troubleshooting/\">Click here for more information.</a>';\r\n\r\n/**\r\n * Creates a webgl context. If creation fails it will\r\n * change the contents of the container of the <canvas>\r\n * tag to an error message with the correct links for WebGL.\r\n * @param {Element} canvas. The canvas element to create a\r\n *     context from.\r\n * @param {WebGLContextCreationAttirbutes} opt_attribs Any\r\n *     creation attributes you want to pass in.\r\n * @return {WebGLRenderingContext} The created context.\r\n */\r\nvar setupWebGL = function(canvas, opt_attribs) {\r\n  function showLink(str) {\r\n    var container = canvas.parentNode;\r\n    if (container) {\r\n      container.innerHTML = makeFailHTML(str);\r\n    }\r\n  };\r\n\r\n  if (!window.WebGLRenderingContext) {\r\n    showLink(GET_A_WEBGL_BROWSER);\r\n    return null;\r\n  }\r\n\r\n  var context = create3DContext(canvas, opt_attribs);\r\n  if (!context) {\r\n    showLink(OTHER_PROBLEM);\r\n  }\r\n  return context;\r\n};\r\n\r\n/**\r\n * Creates a webgl context.\r\n * @param {!Canvas} canvas The canvas tag to get context\r\n *     from. If one is not passed in one will be created.\r\n * @return {!WebGLContext} The created context.\r\n */\r\nvar create3DContext = function(canvas, opt_attribs) {\r\n  var names = [\"webgl\", \"experimental-webgl\", \"webkit-3d\", \"moz-webgl\"];\r\n  var context = null;\r\n  for (var ii = 0; ii < names.length; ++ii) {\r\n    try {\r\n      context = canvas.getContext(names[ii], opt_attribs);\r\n    } catch(e) {}\r\n    if (context) {\r\n      break;\r\n    }\r\n  }\r\n  return context;\r\n}\r\n\r\nreturn {\r\n  create3DContext: create3DContext,\r\n  setupWebGL: setupWebGL\r\n};\r\n}();\r\n\r\n/**\r\n * Provides requestAnimationFrame in a cross browser way.\r\n */\r\nwindow.requestAnimFrame = (function() {\r\n  return window.requestAnimationFrame ||\r\n         window.webkitRequestAnimationFrame ||\r\n         window.mozRequestAnimationFrame ||\r\n         window.oRequestAnimationFrame ||\r\n         window.msRequestAnimationFrame ||\r\n         function(/* function FrameRequestCallback */ callback, /* DOMElement Element */ element) {\r\n           window.setTimeout(callback, 1000/60);\r\n         };\r\n})();\r\n\r\n\r\n","function loadDocument(path) {\n    let request = new XMLHttpRequest();\n    request.open(\"GET\", path, false);\n    request.send();\n\n    if (request.readyState == 4 && request.status == 200) {\n        return request.responseText;\n    }\n    \n    return '';\n}\n","function initShaders(gl, vertexShader, fragmentShader) {\n    let program = gl.createProgram();\n\n    if (!vertexShader) {\n        return;\n    } else {\n        let shader = gl.createShader(gl.VERTEX_SHADER);\n        gl.shaderSource(shader, vertexShader);\n        gl.compileShader(shader);\n\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n            return;\n        }\n\n        gl.attachShader(program, shader);\n    }\n\n    if (!fragmentShader) {\n        return;\n    } else {\n        let shader = gl.createShader(gl.FRAGMENT_SHADER);\n        gl.shaderSource(shader, fragmentShader);\n        gl.compileShader(shader);\n\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n            return;\n        }\n        \n        gl.attachShader(program, shader);\n    }\n    \n    gl.linkProgram(program);\n\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        return;\n    }\n\n    return program;\n}\n","const randColorFunction = (faces, points) => {\n  let returnArray = new Array(faces.length);\n  for (let x = 0; x < faces.length; x++) {\n    returnArray[x] = vec4(Math.random(), Math.random(), Math.random(), 1);\n  }\n\n  return returnArray;\n}\n\n// Default color function - normal of each surface norm (creates rainbow-ish coloring)\nconst defaultColorFunction = (faces, points) => {\n  let returnArray = new Array(faces.length);\n  for (let x = 0; x < faces.length; x += 3) {\n    let p0 = 3 * faces[x];\n    let p1 = 3 * faces[x + 1];\n    let p2 = 3 * faces[x + 2];\n\n    // Get the surface normal (cross 2 edges) and normalize the vector\n    let norm = normalize(cross(\n      vec3(points[p1] - points[p0], points[p1 + 1] - points[p0 + 1], points[p1 + 2] - points[p0 + 2]),\n      vec3(points[p2] - points[p0], points[p2 + 1] - points[p0 + 1], points[p2 + 2] - points[p0 + 2])\n    ));\n\n    // Take the absolute value of the normalized vector\n    let color = vec4(Math.abs(norm[0]), Math.abs(norm[1]), Math.abs(norm[2]), 1);\n\n    // Apply the color across the vertices of the face\n    returnArray[x] = color;\n    returnArray[x + 1] = color;\n    returnArray[x + 2] = color;\n  }\n\n  return returnArray;\n}\n\n// Produce a uniform rainbow across the vertices of the shape\nconst rainbowColorFunction = (a, b) => {\n  var returnArray = new Array(b - a);\n\n  // Calculate RGB as a function of an angle.\n  // The three sine waves are offset, so when each value is 1, \n  // the other two are 0 which gives the color at each vertex as \n  // if they were circumscribed by a rainbow. \n  // This is seen best with a triangle or a circle.\n  let red = (angle) => Math.max(0, Math.sin(radians(angle) + Math.PI / 2));\n  let green = (angle) => Math.max(0, Math.sin(radians(angle)));\n  let blue = (angle) => Math.max(0, Math.sin(radians(angle) - Math.PI / 2));\n\n  // The smallest sample where these waves meet the above property \n  // is on the domain [ 0, PI ] (inclusive). So take the current index\n  // and shift it into this range, then calculate the colors.\n  for (let x = a; x < b; x++) {\n    let angle = 180 * x / (b - a - 1);\n    returnArray[x - a] = new vec4(red(angle), green(angle), blue(angle), 1);\n  }\n\n  return returnArray;\n}\n\n// Produce a uniform color rainbow across the vertices of the shape \n// which blends back from blue to red to create a color wheel type rainbow\nconst blendedRainbowColorFunction = (a, b) => {\n  var returnArray = new Array(b - a);\n\n  // This took a while to hash out...\n  let red = (angle) => Math.sin(3 * radians(angle) / 2 + Math.PI / 2) +\n    Math.max(0, -Math.sin(3 * radians(angle) / 2) +\n      Math.sin(3 * radians(angle) / 2 - Math.PI / 2));\n  let green = (angle) => Math.max(0, Math.sin(3 * radians(angle) / 2));\n  let blue = (angle) => Math.max(0, Math.sin(3 * radians(angle) / 2 - Math.PI / 2));\n\n  for (let x = a; x < b; x++) {\n    let angle = 180 * x / (b - a - 1);\n    returnArray[x - a] = new vec4(red(angle), green(angle), blue(angle), 1);\n  }\n\n  return returnArray;\n}\n\n// Converts a provided vec4 into a function to\n// color vertices of a shape the provided color\nconst createSolidColorFunction = (color) => {\n  return (a, b) => new Array(b - a).fill(color);\n}\n","const PROJECTIONS = {\n  Perspective: 0,\n  Parallel: 1\n};\n\nconst PROJ_NAMES = [\"Perspective\", \"Parallel\"];\n\n// Default material properties\nconst MAT_DEFAULT = {\n  ambient: vec4(1.0, 1.0, 1.0, 1.0),\n  diffuse: vec4(1.0, 1.0, 1.0, 1.0),\n  specular: vec4(1.0, 1.0, 1.0, 1.0),\n  shininess: 50.0\n};\n\nconst up = vec3(0, 1, 0);\n\nconst BUNNY = parseSMF(loadDocument('../assets/smf/bunny.smf'));\nconst CUBE = parseSMF(loadDocument('../assets/smf/cube.smf'));\nconst FISH = parseSMF(loadDocument('../assets/smf/fish.smf'));\nconst SPHERE = parseSMF(loadDocument('../assets/smf/sphere.smf'));\nconst TEAPOT = parseSMF(loadDocument('../assets/smf/teapot.smf'));\n\nconst VERT_SHADER_BASIC = loadDocument('../assets/shaders/basic.vertex');\nconst VERT_SHADER_PHONG = loadDocument('../assets/shaders/phong.vertex');\nconst VERT_SHADER_GOURAUD = loadDocument('../assets/shaders/gouraud.vertex');\n\nconst FRAG_SHADER_BASIC = loadDocument('../assets/shaders/basic.fragment');\nconst FRAG_SHADER_PHONG = loadDocument('../assets/shaders/phong.fragment');\nconst FRAG_SHADER_GOURAUD = loadDocument('../assets/shaders/gouraud.fragment');\n","var webgl_webgl;\n\nfunction parseSMF(fileData) {\n  let returnData = [];\n\n  fileData.match(/[^\\r\\n]+/g).forEach(line => {\n    let chunked = line.split(',');\n    returnData.push(chunked[0]);\n    returnData.push(+chunked[1]);\n    returnData.push(+chunked[2]);\n    returnData.push(+chunked[3]);\n  });\n\n  return returnData;\n}\n\nfunction createCanvas1() {\n  if (webgl_webgl) webgl_webgl.cleanup(webgl_webgl);\n  \n  webgl_webgl = StandardWebGL(document.getElementById(\"gl-canvas\"));\n  webgl_webgl.UseBasic(webgl_webgl);\n  webgl_webgl.fieldDepth = [-0.4, 0.7, -0.4, 0.4, -1, 1];\n\n  let pentagon = createPentagon(-0.3, -0.3, 0.3, -0.3, 0.6, 0.0, 0.3, 0.3, -0.3, 0.3,\n    createSolidColorFunction(vec4(1.0, 0.0, 0.0, 1.0)));\n  webgl_webgl.shapes.push.apply(webgl_webgl.shapes, pentagon);\n\n  renderShapes(webgl_webgl);\n}\n\nfunction createCanvas2() {\n  if (webgl_webgl) webgl_webgl.cleanup(webgl_webgl);\n  \n  webgl_webgl = StandardWebGL(document.getElementById(\"gl-canvas\"));\n  webgl_webgl.UseBasic(webgl_webgl);\n  webgl_webgl.fieldDepth = 1.25;\n\n  let colorRed = createSolidColorFunction(new vec4(1, 0, 0, 1));\n  let colorWhite = createSolidColorFunction(new vec4(1, 1, 1, 1));\n  let colorBlack = createSolidColorFunction(new vec4(0, 0, 0, 1));\n\n  // Create squares\n  let sqCent = [0.0, -0.3];\n  for (let sqID = 6; sqID > 0; sqID--) {\n    let delta = 0.1 * sqID;\n\n    let x0 = sqCent[0] - delta;\n    let x1 = sqCent[0] + delta;\n    let y0 = sqCent[1] - delta;\n    let y1 = sqCent[1] + delta;\n\n    if (sqID % 2 == 0) {\n      webgl_webgl.shapes.push.apply(webgl_webgl.shapes, createSquare(x0, y0, x1, y1, colorWhite));\n    } else {\n      webgl_webgl.shapes.push.apply(webgl_webgl.shapes, createSquare(x0, y0, x1, y1, colorBlack));\n    }\n  }\n\n  // Create multi-color circle\n  webgl_webgl.shapes.push.apply(webgl_webgl.shapes, createEllipse(0.6, 0.7, 0.2, 0.2,\n    (a, b) => {\n      var returnArray = new Array(b - a);\n\n      for (let x = a; x < b; x++) {\n        returnArray[x] = new vec4(x / (b - a), 0, 0, 1);\n      }\n\n      return returnArray;\n    }));\n\n  // Create red ellipse\n  webgl_webgl.shapes.push.apply(webgl_webgl.shapes, createEllipse(-0.6, 0.625, 0.2, 0.12, colorRed));\n\n  // Create rainbow triangle\n  webgl_webgl.shapes.push.apply(webgl_webgl.shapes, createTriangle(0.0, 1.0, -0.3, 0.5, 0.3, 0.5, rainbowColorFunction));\n\n  renderShapes(webgl_webgl);\n}\n\nfunction createCanvas3() {\n  if (webgl_webgl) webgl_webgl.cleanup(webgl_webgl);\n  \n  webgl_webgl = StandardWebGL(document.getElementById(\"gl-canvas\"));\n  webgl_webgl.UseBasic(webgl_webgl);\n  webgl_webgl.rot[0] = 45;\n  webgl_webgl.height = 0.5;\n\n  webgl_webgl.shapes.push.apply(webgl_webgl.shapes, createMesh(CUBE, (a, b) => [\n    vec4(1.0, 0.0, 0.0, 1.0), // Red\n    vec4(1.0, 1.0, 0.0, 1.0), // Yellow\n    vec4(1.0, 1.0, 1.0, 1.0), // White\n    vec4(1.0, 0.0, 1.0, 1.0), // Magenta\n    vec4(0.0, 0.0, 0.0, 1.0), // Black\n    vec4(0.0, 0.0, 1.0, 1.0), // Blue\n    vec4(0.0, 1.0, 1.0, 1.0), // Cyan\n    vec4(0.0, 1.0, 0.0, 1.0), // Green\n  ]));\n  renderShapes(webgl_webgl);\n}\n\nfunction createCanvas4() {\n  if (webgl_webgl) webgl_webgl.cleanup(webgl_webgl);\n  \n  webgl_webgl = StandardWebGL(document.getElementById(\"gl-canvas\"));\n  webgl_webgl.UseBasic(webgl_webgl);\n  \n  webgl_webgl.shapes.push.apply(webgl_webgl.shapes, createMeshUniqueVertices(BUNNY, null));\n  renderShapes(webgl_webgl);\n}\n\nfunction createCanvas5() {\n  if (webgl_webgl) webgl_webgl.cleanup(webgl_webgl);\n  \n  webgl_webgl = StandardWebGL(document.getElementById(\"gl-canvas\"));\n  webgl_webgl.UsePhong(webgl_webgl);\n\n  webgl_webgl.shapes.push.apply(webgl_webgl.shapes, createMeshUniqueVertices(TEAPOT, null));\n  renderShapes(webgl_webgl);\n}\n\n\nfunction roundToFixed(val, len) {\n  return parseFloat((Math.round(val * Math.pow(10, len)) / Math.pow(10, len)).toFixed(len));\n}\n\nfunction changeModel() {\n  let element = document.getElementById(\"modelSelection\");\n  let value = element.options[element.selectedIndex].value.toUpperCase();\n\n  if (CurrentModel == value) return;\n\n  if (value == \"BUNNY\") {\n    webgl_webgl.shapes = createMeshUniqueVertices(BUNNY, null);\n  } else if (value == \"CUBE\") {\n    webgl_webgl.shapes = createMeshUniqueVertices(CUBE, null);\n  } else if (value == \"FISH\") {\n    webgl_webgl.shapes = createMeshUniqueVertices(FISH, null);\n  } else if (value == \"SPHERE\") {\n    webgl_webgl.shapes = createMeshUniqueVertices(SPHERE, null);\n  } else if (value == \"TEAPOT\") {\n    webgl_webgl.shapes = createMeshUniqueVertices(TEAPOT, null);\n  }\n\n  changeMaterial();\n\n  CurrentModel = value;\n  webgl_webgl.changed = true;\n}\n\nfunction changeMaterial() {\n  let element = document.getElementById(\"materialSelection\");\n  let value = element.options[element.selectedIndex].value.toUpperCase();\n\n  let selected = MAT_DEFAULT;\n  if (value == 'GOLD') {\n    selected = {\n      ambient: vec4(218.0 / 255.0, 165.0 / 255.0, 32.0 / 255.0, 1.0),\n      diffuse: vec4(1.0, 215.0 / 255.0, 0.0, 1.0),\n      specular: vec4(238.0 / 255.0, 232.0 / 255.0, 170.0 / 255.0, 1.0),\n      shininess: 5.0\n    };\n  } else if (value == 'COAL') {\n    selected = {\n      ambient: vec4(0.1, 0.1, 0.1, 1.0),\n      diffuse: vec4(0.3, 0.3, 0.3, 1.0),\n      specular: vec4(0.1, 0.1, 0.1, 1.0),\n      shininess: 10000.0\n    };\n  } else if (value == 'POLISHEDSILVER') {\n    selected = {\n      ambient: vec4(169.0 / 255.0, 169.0 / 255.0, 169.0 / 255.0, 1.0),\n      diffuse: vec4(192.0 / 255.0, 192.0 / 255.0, 192.0 / 255.0, 1.0),\n      specular: vec4(211.0 / 255.0, 211.0 / 255.0, 211.0 / 255.0, 1.0),\n      shininess: 20.0\n    };\n  } else if (value == 'REDSHINY') {\n    selected = {\n      ambient: vec4(0.6, 0.2, 0.2, 1.0),\n      diffuse: vec4(0.9, 0.1, 0.1, 1.0),\n      specular: vec4(0.8, 0.8, 0.8, 1.0),\n      shininess: 80.0\n    };\n  } else {\n    return;\n  }\n\n  webgl_webgl.shapes.forEach(shape => {\n    shape.material = selected;\n  });\n  webgl_webgl.changed = true;\n}\n\nfunction updateLightDirectedVal() {\n  let checked = document.getElementById(\"directedLight\").checked;\n  webgl_webgl.light.directed = checked;\n  document.getElementById(\"directedLabel\").innerHTML = checked ? 'On  ' : 'Off  ';\n  webgl_webgl.changed = true;\n}\n","function applyLightData(webgl, light) {\n  if (webgl.attributes.simple) return;\n\n  // Apply the properties for the light source to the scene\n\n  let vecAmbient = webgl.attributes.vecAmbientL;\n  let vecDiffuse = webgl.attributes.vecDiffuseL;\n  let vecSpecular = webgl.attributes.vecSpecularL;\n  let vecLight = webgl.attributes.vecLight;\n\n  webgl.gl.uniform4fv(vecAmbient, flatten(light.ambient));\n  webgl.gl.uniform4fv(vecDiffuse, flatten(light.diffuse));\n  webgl.gl.uniform4fv(vecSpecular, flatten(light.specular));\n  webgl.gl.uniform4fv(vecLight, flatten(light.source));\n}\n\nfunction applyMaterialData(webgl, material) {\n  if (webgl.attributes.simple) return;\n\n  // Apply the properties of the material to the scene \n  // (Allows multiple materials to be rendered in the same scene if needed)\n\n  let vecAmbient = webgl.attributes.vecAmbientM;\n  let vecDiffuse = webgl.attributes.vecDiffuseM;\n  let vecSpecular = webgl.attributes.vecSpecularM;\n  let floatShininess = webgl.attributes.floatShininess;\n\n  if (material != null) {\n    webgl.gl.uniform4fv(vecAmbient, flatten(material.ambient));\n    webgl.gl.uniform4fv(vecDiffuse, flatten(material.diffuse));\n    webgl.gl.uniform4fv(vecSpecular, flatten(material.specular));\n    webgl.gl.uniform1f(floatShininess, material.shininess);\n  } else {\n    // Use default material\n    webgl.gl.uniform4fv(vecAmbient, flatten(MAT_DEFAULT.ambient));\n    webgl.gl.uniform4fv(vecDiffuse, flatten(MAT_DEFAULT.diffuse));\n    webgl.gl.uniform4fv(vecSpecular, flatten(MAT_DEFAULT.specular));\n    webgl.gl.uniform1f(floatShininess, MAT_DEFAULT.shininess);\n  }\n}\n\n// Render the shapes provided using the attributes. \nfunction renderShapes(webgl) {\n  let bufferData = [];\n  let chunkData = [];\n\n  // All rendering is done in chunks with a shape in each chunk.\n  // If a shape is too large, it will be split across multiple chunks\n  // but each chunk can only contain data for a single shape\n  function setupRenderChunks() {\n    chunkData = [];\n\n    webgl.shapes.forEach(Shape => {\n      // Chunk data: size of chunk, shape points, colors, normals, indices, and material data\n      let chunkNode = {\n        size: 0,\n        points: [],\n        colors: [],\n        normals: [],\n        indices: [],\n        material: null\n      };\n\n      Shape.points.forEach(point => chunkNode.points.push(point));\n      Shape.colors.forEach(color => chunkNode.colors.push(color));\n      Shape.normals.forEach(normal => chunkNode.normals.push(normal));\n      Shape.indices.forEach(index => chunkNode.indices.push(index));\n      chunkNode.material = Shape.material;\n\n      chunkNode.size = chunkNode.indices.length;\n      chunkData.push(chunkNode);\n    });\n\n    // Setup the data to render\n    webgl.bufferData = setupAttributeBuffers(webgl, chunkData[0]);\n    webgl.bufferData.prepMultiBuffer(chunkData[0]);\n    applyMaterialData(webgl, chunkData[0].material);\n\n    // Delete buffers if they already exist\n    if ((bufferData || []).length > 0) {\n      bufferData.disablePos();\n      bufferData.disableNorm();\n      bufferData.disableColor();\n      bufferData.deleteBuffers();\n    }\n\n    // Update the buffer data reference\n    bufferData = webgl.bufferData;\n  }\n\n  function animate(time) {\n\n    if (webgl.attributes == null) {\n      return;\n    }\n\n    // Update the render chunks if there has been a major property change\n    // (caused by shape changes, rendering program changes, etc)\n    if (webgl.changed) {\n      webgl.changed = false;\n      setupRenderChunks();\n    }\n\n    webgl.gl.clear(webgl.gl.COLOR_BUFFER_BIT | webgl.gl.DEPTH_BUFFER_BIT);\n\n    let fieldDepths = null;\n\n    // Ensure the current WebGL configuration includes field depths, \n    // or default to a bounding box of +/- 1 in all directions. \n    // Possible field depths are single integer values, 3-length, \n    // or 6-length arrays. \n    // Single ints will be +/- the value in all directions.\n    // 3-length arrays will be +/- the respective X, Y, and Z values.\n    if (!webgl.fieldDepth)\n      fieldDepths = [-1, 1, -1, 1, -1, 1];\n    else if (webgl.fieldDepth.constructor === Array)\n      if (webgl.fieldDepth.length == 3) {\n        let depthX = Math.abs(webgl.fieldDepth[0]);\n        let depthY = Math.abs(webgl.fieldDepth[1]);\n        let depthZ = Math.abs(webgl.fieldDepth[2]);\n        fieldDepths = [-depthX, depthX, -depthY, depthY, -depthZ, depthZ];\n      } else\n        fieldDepths = webgl.fieldDepth;\n    else {\n      let depth = Math.abs(webgl.fieldDepth);\n      fieldDepths = [-depth, depth, -depth, depth, -depth, depth];\n    }\n\n    // Calculate the height of the camera in a better way than last assignment\n    // This simplifies the eye math, as y will be the percentage of the X and Z\n    // components to use, allowing height to represent the actual height of the eye\n    let y = Math.sin(Math.PI / (2 * webgl.radius) * (Math.abs(webgl.height) + webgl.radius));\n    let yLight = Math.sin(Math.PI / (2 * webgl.light.radius) * (Math.abs(webgl.light.height) + webgl.light.radius));\n\n    // Calculate location of eye\n    let eye = vec3(\n      y * webgl.radius * Math.sin(radians(webgl.rot[0])),\n      webgl.height,\n      y * webgl.radius * Math.cos(radians(webgl.rot[0])));\n\n    webgl.light.source = vec3(\n      yLight * webgl.light.radius * Math.sin(radians(webgl.light.rot[0])),\n      webgl.light.height,\n      yLight * webgl.light.radius * Math.cos(radians(webgl.light.rot[0])));\n\n    webgl.light.source = vec4(webgl.light.source, webgl.light.directed ? 1.0 : 0.0);\n\n    let viewMatrix = lookAt(eye, webgl.center, up);\n    let projMatrix = null;\n\n    // If the projection is parallel default to orthographic, otherwise use perspective\n    if (webgl.projection == PROJECTIONS.Parallel) {\n      projMatrix = ortho(fieldDepths[0], fieldDepths[1], fieldDepths[2], fieldDepths[3], fieldDepths[4], fieldDepths[5]);\n    } else {\n      projMatrix = perspective(webgl.fov, webgl.aspect, fieldDepths[4], fieldDepths[5]);\n    }\n\n    // Stage the matrix translations for the shader\n    webgl.gl.uniformMatrix4fv(webgl.attributes.matrixView, false, flatten(viewMatrix));\n\n    if (!webgl.attributes.simple) {\n      webgl.gl.uniformMatrix3fv(webgl.attributes.matrixNormal, false, flatten(\n        [normalize(viewMatrix[0].slice(0, 3)),\n          normalize(viewMatrix[1].slice(0, 3)),\n          normalize(viewMatrix[2].slice(0, 3))\n        ]));\n    }\n    webgl.gl.uniformMatrix4fv(webgl.attributes.matrixProject, false, flatten(projMatrix));\n    applyLightData(webgl, webgl.light);\n\n    chunkData.forEach(chunk => {\n      // Heuristic improvement. Don't re-bind the same data if there's only one chunk\n      if (chunkData.length > 1) {\n        bufferData.prepMultiBuffer(chunk);\n        applyMaterialData(webgl, chunk.material);\n      }\n\n      webgl.gl.drawElements(webgl.gl.TRIANGLES, chunk.size, webgl.gl.UNSIGNED_SHORT, 0);\n    })\n\n    // Request another animation frame\n    window.requestAnimationFrame(animate);\n  }\n\n  setupRenderChunks();\n  animate(0);\n}\n","// Standard webgl setup\nfunction StandardWebGL(canvas) {\n  var gl = WebGLUtils.setupWebGL(canvas);\n  if (!gl) {\n    alert(\"WebGL isn't available\");\n  }\n\n  gl.viewport(0, 0, canvas.width, canvas.height);\n  gl.clearColor(0.0, 0.0, 0.0, 1.0);\n  gl.clearDepth(1.0);\n\n  gl.enable(gl.DEPTH_TEST);\n  gl.depthFunc(gl.LEQUAL);\n\n  // Initialize both shader programs\n  var gouraud = initShaders(gl, VERT_SHADER_GOURAUD, FRAG_SHADER_GOURAUD);\n  var phong = initShaders(gl, VERT_SHADER_PHONG, FRAG_SHADER_PHONG);\n  var basic = initShaders(gl, VERT_SHADER_BASIC, FRAG_SHADER_BASIC);\n\n  // Initialize both programs' attributes\n  var attributesGouraud = getProgramAttributesComplex(gl, gouraud);\n  var attributesPhong = getProgramAttributesComplex(gl, phong);\n  var attributesBasic = getProgramAttributesBasic(gl, basic);\n\n  gl.useProgram(gouraud);\n\n  // Objects should be passed by reference allowing later\n  // updates to the properties of the WebGL instance to \n  // make changing the projection configuration easier\n  return {\n    // Shader/program data:\n    gl: gl,\n    program: gouraud,\n    programName: 'Gouraud',\n    attributes: attributesGouraud,\n    shapes: [],\n    changed: false,\n    fieldDepth: 2,\n    fov: 45,\n    aspect: canvas.width / canvas.height,\n    projection: PROJECTIONS.Parallel,\n    rot: [0, 0, 0],\n    height: 0,\n    radius: 1,\n    center: vec3(0, 0, 0),\n    light: {\n      ambient: vec4(0.2, 0.2, 0.2, 1.0),\n      diffuse: vec4(0.6, 0.6, 0.6, 1.0),\n      specular: vec4(1.0, 1.0, 1.0, 1.0),\n      source: vec4(0.0, 0.0, 0.0, 0.0),\n      rot: [0, 0, 0],\n      height: 0,\n      radius: 1,\n      directed: false\n    },\n    bufferData: null,\n    cleanup: (webgl) => {\n        if (webgl.bufferData != null) {\n            webgl.bufferData.disablePos();\n            webgl.bufferData.disableNorm();\n            webgl.bufferData.disableColor();\n            webgl.bufferData.deleteBuffers();\n        }\n\n        webgl.attributes = null;\n        webgl.bufferData = null;\n    },\n    UseGouraud: (webgl) => {\n      // Currently using this shader or the buffer data is missing. Can't update\n      if (webgl.programName == 'Gouraud') {\n        return;\n      }\n\n      // Update program data and attributes\n      webgl.programName = 'Gouraud';\n      webgl.gl.useProgram(gouraud);\n      webgl.attributes = attributesGouraud;\n\n      // Update the buffers\n      if (webgl.bufferData != null) webgl.bufferData.updateProgram();\n\n      // Tell the animate function to re-buffer the data for the shapes\n      webgl.changed = true;\n    },\n    UsePhong: (webgl) => {\n      // See comments in UseGouraud\n\n      if (webgl.programName == 'Phong') {\n        return;\n      }\n\n      webgl.programName = 'Phong';\n      webgl.gl.useProgram(phong);\n      webgl.attributes = attributesPhong;\n      if (webgl.bufferData != null) webgl.bufferData.updateProgram();\n      webgl.changed = true;\n    },\n    UseBasic: (webgl) => {\n      // See comments in UseGouraud\n\n      if (webgl.programName == 'Basic') {\n        return;\n      }\n      \n      webgl.programName = 'Basic';\n      webgl.gl.useProgram(basic);\n      webgl.attributes = attributesBasic;\n      if (webgl.bufferData != null) webgl.bufferData.updateProgram();\n      webgl.changed = true;\n    },\n  };\n}\n\n// Get vertex position and normal attributes, plus \n// material and lighting uniforms for a provided program\nfunction getProgramAttributesComplex(gl, program) {\n  var vPosition = gl.getAttribLocation(program, 'vPosition');\n  var vNormal = gl.getAttribLocation(program, 'vNormal');\n\n  var uModel = gl.getUniformLocation(program, 'uModel');\n  var uNormal = gl.getUniformLocation(program, 'uNormal');\n  var uProject = gl.getUniformLocation(program, 'uProject');\n\n  // Light properties\n  var uLightAmbient = gl.getUniformLocation(program, 'uLightAmbient');\n  var uLightDiffuse = gl.getUniformLocation(program, 'uLightDiffuse');\n  var uLightSpecular = gl.getUniformLocation(program, 'uLightSpecular');\n  var uLightPos = gl.getUniformLocation(program, 'uLightPos');\n\n  // Material properties\n  var uMatAmbient = gl.getUniformLocation(program, 'uMaterialAmbient');\n  var uMatDiffuse = gl.getUniformLocation(program, 'uMaterialDiffuse');\n  var uMatSpecular = gl.getUniformLocation(program, 'uMaterialSpecular');\n\n  var uShiny = gl.getUniformLocation(program, 'uShiny');\n\n  return {\n    positionAttribute: vPosition,\n    normalAttribute: vNormal,\n\n    matrixView: uModel,\n    matrixNormal: uNormal,\n    matrixProject: uProject,\n\n    vecAmbientL: uLightAmbient,\n    vecDiffuseL: uLightDiffuse,\n    vecSpecularL: uLightSpecular,\n    vecLight: uLightPos,\n\n    vecAmbientM: uMatAmbient,\n    vecDiffuseM: uMatDiffuse,\n    vecSpecularM: uMatSpecular,\n    floatShininess: uShiny,\n\n    simple: false\n  };\n}\n\n// Get color and vertex position attributes \n// for a provided program\nfunction getProgramAttributesBasic(gl, program) {\n  var vPosition = gl.getAttribLocation(program, 'vPosition');\n  var vColor = gl.getAttribLocation(program, 'vColor');\n\n  var uModel = gl.getUniformLocation(program, 'uModel');\n  var uProject = gl.getUniformLocation(program, 'uProject');\n\n  return {\n    positionAttribute: vPosition,\n    colorAttribute: vColor,\n\n    matrixView: uModel,\n    matrixProject: uProject,\n\n    simple: true\n  };\n}\n\n// Setup buffers for vertices and indices\nfunction setupAttributeBuffers(webgl, chunk) {\n  var posBuffer = null;\n  var normBuffer = null;\n  var colorBuffer = null;\n  var indexBuffer = null;\n\n  var posAttribute = null;\n  var normAttribute = null;\n  var colorAttribute = null;\n\n  // Position buffer bind and fill:\n  posBuffer = webgl.gl.createBuffer();\n  posAttribute = webgl.attributes.positionAttribute;\n  webgl.gl.bindBuffer(webgl.gl.ARRAY_BUFFER, posBuffer);\n  webgl.gl.bufferData(webgl.gl.ARRAY_BUFFER, flatten(chunk.points), webgl.gl.STATIC_DRAW);\n  webgl.gl.vertexAttribPointer(posAttribute, 3, webgl.gl.FLOAT, false, 0, 0);\n  webgl.gl.enableVertexAttribArray(posAttribute);\n\n  if (webgl.attributes.simple) {\n    // Color buffer bind and fill:\n    colorBuffer = webgl.gl.createBuffer();\n    colorAttribute = webgl.attributes.normalAttribute;\n    webgl.gl.bindBuffer(webgl.gl.ARRAY_BUFFER, colorBuffer);\n    webgl.gl.bufferData(webgl.gl.ARRAY_BUFFER, flatten(chunk.normals), webgl.gl.STATIC_DRAW);\n    webgl.gl.vertexAttribPointer(colorAttribute, 4, webgl.gl.FLOAT, false, 0, 0);\n    webgl.gl.enableVertexAttribArray(colorAttribute);\n  } else {\n    // Normal buffer bind and fill:\n    normBuffer = webgl.gl.createBuffer();\n    normAttribute = webgl.attributes.normalAttribute;\n    webgl.gl.bindBuffer(webgl.gl.ARRAY_BUFFER, normBuffer);\n    webgl.gl.bufferData(webgl.gl.ARRAY_BUFFER, flatten(chunk.normals), webgl.gl.STATIC_DRAW);\n    webgl.gl.vertexAttribPointer(normAttribute, 3, webgl.gl.FLOAT, false, 0, 0);\n    webgl.gl.enableVertexAttribArray(normAttribute);\n  }\n\n  // Index buffer bind and fill:\n  indexBuffer = webgl.gl.createBuffer();\n  webgl.gl.bindBuffer(webgl.gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\n  webgl.gl.bufferData(webgl.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(chunk.indices), webgl.gl.DYNAMIC_DRAW);\n\n  // Surprisingly JavaScript can maintain the references to the buffer \n  // variables when the prepMultiBuffer function call updates them. Cool.\n  return {\n    disablePos: () => posAttribute != null ? webgl.gl.disableVertexAttribArray(posAttribute) : (() => {})(),\n    disableNorm: () => normAttribute != null ? webgl.gl.disableVertexAttribArray(normAttribute) : (() => {})(),\n    disableColor: () => colorAttribute != null ? webgl.gl.disableVertexAttribArray(colorAttribute) : (() => {})(),\n    prepMultiBuffer: (multiData) => {\n      webgl.gl.deleteBuffer(posBuffer);\n\n      // Position buffer bind and fill:\n      posBuffer = webgl.gl.createBuffer();\n      posAttribute = webgl.attributes.positionAttribute;\n      webgl.gl.bindBuffer(webgl.gl.ARRAY_BUFFER, posBuffer);\n      webgl.gl.bufferData(webgl.gl.ARRAY_BUFFER, flatten(multiData.points), webgl.gl.STATIC_DRAW);\n      webgl.gl.vertexAttribPointer(posAttribute, 3, webgl.gl.FLOAT, false, 0, 0);\n      webgl.gl.enableVertexAttribArray(posAttribute);\n\n      if (webgl.attributes.simple) {\n        // Normal buffer bind and fill:\n        colorBuffer = webgl.gl.createBuffer();\n        colorAttribute = webgl.attributes.colorAttribute;\n        webgl.gl.bindBuffer(webgl.gl.ARRAY_BUFFER, colorBuffer);\n        webgl.gl.bufferData(webgl.gl.ARRAY_BUFFER, flatten(multiData.colors), webgl.gl.STATIC_DRAW);\n        webgl.gl.vertexAttribPointer(colorAttribute, 4, webgl.gl.FLOAT, false, 0, 0);\n        webgl.gl.enableVertexAttribArray(colorAttribute);\n      } else {\n        // Normal buffer bind and fill:\n        normBuffer = webgl.gl.createBuffer();\n        normAttribute = webgl.attributes.normalAttribute;\n        webgl.gl.bindBuffer(webgl.gl.ARRAY_BUFFER, normBuffer);\n        webgl.gl.bufferData(webgl.gl.ARRAY_BUFFER, flatten(multiData.normals), webgl.gl.STATIC_DRAW);\n        webgl.gl.vertexAttribPointer(normAttribute, 3, webgl.gl.FLOAT, false, 0, 0);\n        webgl.gl.enableVertexAttribArray(normAttribute);\n      }\n\n      // Fix the index buffer\n      webgl.gl.bufferData(webgl.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(multiData.indices), webgl.gl.DYNAMIC_DRAW);\n    },\n    deleteBuffers: () => {\n      // Clean up buffers\n      webgl.gl.deleteBuffer(posBuffer);\n\n      if (webgl.attributes.simple) {\n        webgl.gl.deleteBuffer(colorBuffer);\n      } else {\n        webgl.gl.deleteBuffer(normBuffer);\n      }\n\n      webgl.gl.deleteBuffer(indexBuffer);\n    },\n    updateProgram: () => {\n      /* This will not rebind data!!  */\n\n      // Create a new position buffer\n      let upd_posBuffer = webgl.gl.createBuffer();\n      posAttribute = webgl.attributes.positionAttribute;\n      webgl.gl.bindBuffer(webgl.gl.ARRAY_BUFFER, upd_posBuffer);\n      webgl.gl.vertexAttribPointer(posAttribute, 3, webgl.gl.FLOAT, false, 0, 0);\n      webgl.gl.enableVertexAttribArray(posAttribute);\n\n      let upd_normBuffer = null;\n      let upd_colorBuffer = null;\n      if (webgl.attributes.simple) {\n        // Create a new color buffer\n        upd_colorBuffer = webgl.gl.createBuffer();\n        colorAttribute = webgl.attributes.colorAttribute;\n        webgl.gl.bindBuffer(webgl.gl.ARRAY_BUFFER, upd_colorBuffer);\n        webgl.gl.vertexAttribPointer(colorAttribute, 4, webgl.gl.FLOAT, false, 0, 0);\n        webgl.gl.enableVertexAttribArray(colorAttribute);\n      } else {\n        // Create a new normal buffer\n        upd_normBuffer = webgl.gl.createBuffer();\n        normAttribute = webgl.attributes.normalAttribute;\n        webgl.gl.bindBuffer(webgl.gl.ARRAY_BUFFER, upd_normBuffer);\n        webgl.gl.vertexAttribPointer(normAttribute, 3, webgl.gl.FLOAT, false, 0, 0);\n        webgl.gl.enableVertexAttribArray(normAttribute);\n      }\n\n      // Create a new index buffer\n      let upd_indexBuffer = webgl.gl.createBuffer();\n      webgl.gl.bindBuffer(webgl.gl.ELEMENT_ARRAY_BUFFER, upd_indexBuffer);\n\n      // Remove old buffers\n      webgl.gl.deleteBuffer(posBuffer);\n      if (normBuffer != null) webgl.gl.deleteBuffer(normBuffer);\n      if (colorBuffer != null) webgl.gl.deleteBuffer(colorBuffer);\n      webgl.gl.deleteBuffer(indexBuffer);\n\n      // Update buffer variables so other functions don't break\n      indexBuffer = upd_indexBuffer;\n      colorBuffer = upd_colorBuffer;\n      normBuffer = upd_normBuffer;\n      posBuffer = upd_posBuffer;\n    }\n  };\n}\n","// Create a basic mesh with the provided data. Vertices may be shared.\nfunction createMesh(smfData, colorFunction) {\n  let points = [];\n  let norms = [];\n  let indices = [];\n  let avg = [0, 0, 0];\n  let center = null;\n  let pointCount = 0;\n  let maxIndex = 0;\n\n  for (var i = 0; i < smfData.length; i += 4) {\n    if (smfData[i] == 'v') {\n      let point = new vec3(smfData.slice(i + 1, i + 4));\n      points.push.apply(points, point);\n      norms.push.apply(norms, normalize(point));\n\n      avg[0] += smfData[i + 1];\n      avg[1] += smfData[i + 2];\n      avg[2] += smfData[i + 3];\n\n      pointCount++;\n    } else if (smfData[i] == 'f') {\n      indices.push(smfData[i + 1]);\n      indices.push(smfData[i + 2]);\n      indices.push(smfData[i + 3]);\n      if (smfData[i + 1] > maxIndex) maxIndex = smfData[i + 1];\n      if (smfData[i + 2] > maxIndex) maxIndex = smfData[i + 2];\n      if (smfData[i + 3] > maxIndex) maxIndex = smfData[i + 3];\n    } else if (smfData[i] == 'c') {\n      center = [smfData[i + 1], smfData[i + 2], smfData[i + 3]];\n    }\n  }\n\n  if (!indices.includes(0) && maxIndex > points.length / 3 - 1) {\n    for (let x = 0; x < indices.length; x++) {\n      indices[x] = indices[x] - 1;\n    }\n  }\n\n  if (indices.length > 2 ** 16 - 1) {\n    return _breakShape(points, indices, colorFunction);\n  }\n\n  avg[0] /= pointCount;\n  avg[1] /= pointCount;\n  avg[2] /= pointCount;\n\n  return [{\n    points: points,\n    colors: (colorFunction || defaultColorFunction).apply(this, [indices, points]),\n    normals: norms,\n    indices: indices,\n    center: avg,\n    boundingCenter: center,\n    material: {\n      ambient: vec4(0.6, 0.2, 0.2, 1.0),\n      diffuse: vec4(0.9, 0.1, 0.1, 1.0),\n      specular: vec4(0.8, 0.8, 0.8, 1.0),\n      shininess: 80.0\n    }\n  }];\n}\n\n// Duplicate any shared vertices in the mesh to allow \n// face-specific coloring without any fragment blending\nfunction createMeshUniqueVertices(smfData, colorFunction) {\n\n  let smfPoints = [];\n  let smfIndices = [];\n  let points = [];\n  let norms = [];\n  let indices = [];\n  let avg = [0, 0, 0];\n  let center = null;\n  let pointCount = 0;\n  let maxIndex = 0;\n\n  // Initial process of smf data\n  for (var i = 0; i < smfData.length; i += 4) {\n    if (smfData[i] == 'v') {\n      smfPoints.push.apply(smfPoints, new vec3(smfData.slice(i + 1, i + 4)));\n      avg[0] += smfData[i + 1];\n      avg[1] += smfData[i + 2];\n      avg[2] += smfData[i + 3];\n      pointCount++;\n    } else if (smfData[i] == 'f') {\n      smfIndices.push.apply(smfIndices, smfData.slice(i + 1, i + 4));\n      if (smfData[i + 1] > maxIndex) maxIndex = smfData[i + 1];\n      if (smfData[i + 2] > maxIndex) maxIndex = smfData[i + 2];\n      if (smfData[i + 3] > maxIndex) maxIndex = smfData[i + 3];\n    } else if (smfData[i] == 'c') {\n      center = [smfData[i + 1], smfData[i + 2], smfData[i + 3]];\n    }\n  }\n\n  if (!smfIndices.includes(0) && maxIndex > smfPoints.length / 3 - 1) {\n    for (let x = 0; x < smfIndices.length; x++) {\n      smfIndices[x] = smfIndices[x] - 1;\n    }\n  }\n\n  if (smfIndices.length > 2 ** 16 - 1) {\n    return _breakShape(smfPoints, smfIndices, colorFunction);\n  }\n\n  // Reprocess to ensure no faces share a vertex (to allow coloring)\n  smfIndices.forEach(index => {\n    let point = new vec3(smfPoints.slice(3 * index, 3 * index + 3));\n    points.push.apply(points, point);\n    norms.push.apply(norms, normalize(point));\n    indices.push(indices.length);\n  });\n\n  avg[0] /= pointCount;\n  avg[1] /= pointCount;\n  avg[2] /= pointCount;\n\n  return [{\n    points: points,\n    colors: (colorFunction || defaultColorFunction).apply(this, [indices, points]),\n    normals: norms,\n    indices: indices,\n    center: avg,\n    boundingCenter: center,\n    material: {\n      ambient: vec4(0.6, 0.2, 0.2, 1.0),\n      diffuse: vec4(0.9, 0.1, 0.1, 1.0),\n      specular: vec4(0.8, 0.8, 0.8, 1.0),\n      shininess: 80.0\n    }\n  }];\n}\n\n// Split a shape into multiple smaller components \n// to allow for rendering of multi-part meshes \nfunction _breakShape(points, indices, colorFunction) {\n  let sizes = [];\n  let shapes = [];\n  let limit = 2 ** 15 - 2;\n\n  let counter = indices.length;\n  while (counter > limit) {\n    sizes.push(limit);\n    counter -= limit;\n  }\n  if (counter > 0) sizes.push(counter);\n\n  counter = 0;\n\n  // Break each sub-shape and track it individually \n  sizes.forEach(size => {\n    let avg = [0, 0, 0];\n    let shapePoints = [];\n    let shapeIndices = [];\n    let shapeNorms = [];\n\n    indices.slice(counter, counter + size).forEach(index => {\n      let point = new vec3(points.slice(3 * index, 3 * index + 3));\n      shapePoints.push.apply(shapePoints, point);\n      shapeNorms.push.apply(shapeNorms, normalize(point));\n\n      avg[0] += points[3 * index];\n      avg[1] += points[3 * index + 1];\n      avg[2] += points[3 * index + 2];\n      shapeIndices.push(shapeIndices.length);\n    });\n\n    avg[0] /= shapeIndices.length;\n    avg[1] /= shapeIndices.length;\n    avg[2] /= shapeIndices.length;\n\n    shapes.push({\n      points: shapePoints,\n      colors: (colorFunction || defaultColorFunction).apply(this, [indices, points]),\n      normals: shapeNorms,\n      indices: shapeIndices,\n      center: avg,\n      material: {\n        ambient: vec4(0.6, 0.2, 0.2, 1.0),\n        diffuse: vec4(0.9, 0.1, 0.1, 1.0),\n        specular: vec4(0.8, 0.8, 0.8, 1.0),\n        shininess: 80.0\n      }\n    });\n\n    counter += size;\n  });\n\n  return shapes;\n}\n\n// Create a square between the two provided points\nfunction createSquare(x1, y1, x2, y2, colorFunction) {\n  return createRectangle(x1, y1, x1, y2, x2, y2, x2, y1, colorFunction);\n}\n\n// Create a rectangle using the four specified poitns\nfunction createRectangle(x1, y1, x2, y2, x3, y3, x4, y4, colorFunction) {\n  let points = [new vec3(x1, y1, 0), new vec3(x2, y2, 0), new vec3(x3, y3, 0), new vec3(x4, y4, 0)];\n  let xAvg = (x1 + x2 + x3 + x4) / 4;\n  let yAvg = (y1 + y2 + y3 + y4) / 4;\n\n  return [{\n    points: points,\n    colors: (colorFunction || blendedRainbowColorFunction).apply(this, [0, points.length]),\n    normals: points,\n    indices: [0, 1, 2, 0, 2, 3],\n    center: [xAvg, yAvg, 0],\n    material: {\n      ambient: vec4(0.6, 0.2, 0.2, 1.0),\n      diffuse: vec4(0.9, 0.1, 0.1, 1.0),\n      specular: vec4(0.8, 0.8, 0.8, 1.0),\n      shininess: 80.0\n    }\n  }];\n}\n\n// Create a regular pentagon centered at (x, y) of specified size \nfunction createRegularPentagon(x, y, size, olorFunction) {\n  var dxUp = Math.cos(radians(18)) * size;\n  var dxDown = Math.cos(radians(288)) * size * 1.5;\n  var dyUp = Math.sin(radians(18)) * size;\n  var dyDown = Math.sin(radians(288)) * size / 1.25;\n\n  return createPentagon(x + dxUp, y + dyUp, x, y + size, x - dxUp, y + dyUp,\n    x - dxDown, y + dyDown, x + dxDown, y + dyDown, colorFunction);\n}\n\n// Create a pentagon using the 5 specified points\nfunction createPentagon(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, colorFunction) {\n  let points = [new vec3(x1, y1, 0), new vec3(x2, y2, 0), new vec3(x3, y3, 0), new vec3(x4, y4, 0), new vec3(x5, y5, 0)];\n  let xAvg = (x1 + x2 + x3 + x4 + x5) / 5;\n  let yAvg = (y1 + y2 + y3 + y4 + y5) / 5;\n\n  return [{\n    points: points,\n    colors: (colorFunction || blendedRainbowColorFunction).apply(this, [0, points.length]),\n    normals: points,\n    indices: [0, 1, 3, 0, 3, 4, 1, 2, 3],\n    center: [xAvg, yAvg, 0],\n    material: {\n      ambient: vec4(0.6, 0.2, 0.2, 1.0),\n      diffuse: vec4(0.9, 0.1, 0.1, 1.0),\n      specular: vec4(0.8, 0.8, 0.8, 1.0),\n      shininess: 80.0\n    }\n  }];\n}\n\n// Create a triangle using the three vertices\nfunction createTriangle(x1, y1, x2, y2, x3, y3, colorFunction) {\n  let points = [new vec3(x1, y1, 0), new vec3(x2, y2, 0), new vec3(x3, y3, 0)];\n  let xAvg = (x1 + x2 + x3) / 3;\n  let yAvg = (y1 + y2 + y3) / 3;\n\n  return [{\n    points: points,\n    colors: (colorFunction || blendedRainbowColorFunction).apply(this, [0, points.length]),\n    normals: points,\n    indices: [0, 1, 2],\n    center: [xAvg, yAvg, 0],\n    material: {\n      ambient: vec4(0.6, 0.2, 0.2, 1.0),\n      diffuse: vec4(0.9, 0.1, 0.1, 1.0),\n      specular: vec4(0.8, 0.8, 0.8, 1.0),\n      shininess: 80.0\n    }\n  }];\n}\n\n// Draw an ellipse centered at (x, y)\n// All triangles are pinned at the right-most vertex.\nfunction createEllipse(x, y, a, b, colorFunction) {\n  let points = new Array(360);\n  let shapeIndices = []\n  let xAvg = 0;\n  let yAvg = 0;\n\n  for (let index = 0; index < 360; index++) {\n    points[index] = new vec3(\n      x + a * Math.cos(radians(index)),\n      y + b * Math.sin(radians(index)),\n      0\n    );\n\n    if (index > 1) {\n      shapeIndices.push(0, index - 1, index);\n    }\n\n    xAvg += x + a * Math.cos(radians(index));\n    yAvg += y + b * Math.cos(radians(index));\n  }\n\n  xAvg /= 360;\n  yAvg /= 360;\n\n  return [{\n    points: points,\n    colors: (colorFunction || blendedRainbowColorFunction).apply(this, [0, points.length]),\n    normals: points,\n    indices: shapeIndices,\n    center: [xAvg, yAvg, 0],\n    material: {\n      ambient: vec4(0.6, 0.2, 0.2, 1.0),\n      diffuse: vec4(0.9, 0.1, 0.1, 1.0),\n      specular: vec4(0.8, 0.8, 0.8, 1.0),\n      shininess: 80.0\n    }\n  }];\n}\n\n// Draw an ellipse centered at (x, y)\n// All triangles are pinned at the center point (x, y)\nfunction createEllipse_CenterColor(x, y, a, b, centerColor, colorFunction) {\n  let points = new Array(362);\n  let shapeIndices = []\n\n  // Create first point at center of circle.\n  points[0] = new vec3(x, y, 0);\n  for (let index = 0; index < 360; index++) {\n    points[index + 1] = new vec3(\n      x + a * Math.cos(radians(index)),\n      y + b * Math.sin(radians(index))\n    );\n\n    if (index > 1) {\n      shapeIndices.push(0, index - 1, index);\n    }\n  }\n\n  // Create last point where first outer-circle point is.\n  points[361] = new vec2(x + a, y);\n\n  let colors = (colorFunction || blendedRainbowColorFunction).apply(this, [1, points.length - 1])\n\n  // Ensure the two circle points at (x+a, y) have the same colors\n  colors.push(colors[0]);\n\n  // Return the points and the colors array with a central color\n  return [{\n    points: points,\n    colors: [centerColor].concat(colors),\n    normals: points,\n    indices: shapeIndices,\n    center: [xAvg, yAvg, 0],\n    material: {\n      ambient: vec4(0.6, 0.2, 0.2, 1.0),\n      diffuse: vec4(0.9, 0.1, 0.1, 1.0),\n      specular: vec4(0.8, 0.8, 0.8, 1.0),\n      shininess: 80.0\n    }\n  }];\n}\n"],"sourceRoot":""}